#!/usr/bin/env bash

script_dir="$(cd $(dirname "${BASH_SOURCE[0]}") && pwd)"
dry="0"
if [ -z "$XDG_CONFIG_HOME" ]; then
  echo "no xdg config hom"
  echo "using ~/.config"
  XDG_CONFIG_HOME=$HOME/.config
fi

#if [ -z "$DEV_ENV" ]; then
#  echo "env var DEV_ENV needs to be present"
#  exit 1
#fi

while [[ $# > 0 ]]; do
  if [[ "$1" == "--dry" ]]; then
    dry="1"
  elif [[ -n "${platform:-}" ]]; then
    commitMsg="$1"
  else
    platform="$1"
  fi
  shift
done

echo "platform=$platform"
echo "commitMsg=$commitMsg"

log() {
  if [[ $dry == "1" ]]; then
    echo "[DRY_RUN]: $@"
  else
    echo "$@"
  fi
}

execute() {
  printf -v cmd_str '%q ' "$@"
  log "execute: $cmd_str"
  if [[ $dry == "1" ]]; then
    return
  fi

  "$@"
}

log "--------- dev-env ---------"

cd $script_dir &>/dev/null

init_git_repo() {
  log "initializing git repository for $1"
  pushd "$1" &>/dev/null || return
  trap 'popd &>/dev/null' RETURN
  execute git init
  execute git add --all
  execute git commit -m "Initial Commit"
}

preserve_git_dir() {
  local srcDir="$1"
  local dstDir="$2"
  local tmp_dir="$(mktemp -d)" # create a random temp directory in system default /tmp
  trap 'rm -rf "$tmp_dir"' RETURN
  log ".git dir exists. Preserving to $tmp_dir"
  execute cp -r "$dstDir/.git" "$tmp_dir/"
  execute rm -rf "$dstDir"
  execute cp -r "$(realpath "$srcDir")" "$dstDir"
  execute cp -r "$tmp_dir/.git" "$dstDir"
  log ".git directory restored"
  execute rm -rf "$tmp_dir"
}

create_timestamp() {
  echo "$(date +"%Y%m%d%H%M%S")"
}

get_commit_msg() {
  if [[ -n "${commitMsg:-}" ]]; then
    echo "$commitMsg"
  else
    echo "sync-$(create_timestamp)"
  fi
}

commit_changes() {
  log "committing changes in $1"
  pushd "$1" &>/dev/null || return
  trap 'popd &>/dev/null' RETURN
  execute git add --all
  if [[ ! -d ./.git ]]; then
    # skip the rest if the repo does not exist - especially handy in dry mode
    log "Nothing to do: no git repo in $1"
    return
  fi

  if ! git diff --quiet || ! git diff --cached --quiet; then
    execute git commit -am "$(get_commit_msg)"
    log "changes committed"
  else
    log "no changes to commit"
  fi
}

copy_dir() {
  log ""
  log "##################### copy_dir #####################"
  log "# from: $1"
  log "# to:   $2"

  pushd "$1" &>/dev/null || return
  trap 'popd &>/dev/null' RETURN
  local to=${2%/}
  local dirs=$(find . -maxdepth 1 -mindepth 1 -type d)
  for dir in $dirs; do
    local d=${dir#./}
    log ">>>>>>>>>>>>>>>>>>>>>> START >>>>>>>>>>>>>>>>>>>>"
    log "copying $d"
    log ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    if [[ ! -d $to/$d/.git ]]; then
      init_git_repo "$to/$d"
    fi
    preserve_git_dir "$dir" "$to/$d"
    commit_changes "$to/$d"
    log "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
    log "copied $d"
    log "<<<<<<<<<<<<<<<<<<<<<<< DONE <<<<<<<<<<<<<<<<<<<<"
  done
  log "################### END copy_dir ###################"
}

copy_platform_files() {
  pushd "$1" &>/dev/null || return
  trap 'popd &>/dev/null' RETURN
  local to=${2%/}
  local files=$(find . -maxdepth 1 -mindepth 1 -type f)
  for file in $files; do
    local filename=$(basename $file)
    execute rm -f "$to/$filename"
    execute cp "$(realpath "$file")" "$to/$filename"
  done
}

copy_platform() {
  log ""
  log "#################### copy_platform #################"
  log "# from: $1"
  log "# to:   $2"
  pushd "$1" &>/dev/null || return
  trap 'popd &>/dev/null' RETURN
  local to=${2%/}
  local dirs=$(find . -maxdepth 1 -mindepth 1 -type d)
  for dir in $dirs; do
    local d=${dir#./}
    copy_platform_files "$dir" "$to/$d"
    if [[ -d "$to/$d/.git" ]]; then
      commit_changes "$to/$d"
    fi
  done
  log "################## END copy_platform ###############"
}

copy_file() {
  from=$1
  to=$2
  name=$(basename $from)
  execute rm -f "$to/$name"
  execute cp "$(realpath "$from")" "$to/$name"
}

execute cp $HOME/.bashrc "$HOME/.bashrc.bak$(create_timestamp)"
copy_file env/general/bash/.bashrc $HOME
copy_dir env/general/.config "$XDG_CONFIG_HOME"
copy_dir env/general/.local/share "$HOME/.local/share/"
copy_file env/general/.config/starship.toml "$XDG_CONFIG_HOME"
copy_platform "env/$platform/.config" "$XDG_CONFIG_HOME"

if [[ $dry == "0" ]]; then
  source ~/.bashrc
  hyprctl reload
fi

# Not sure if I want to do that by default
#if [[ $dry == "0" ]]; then
#  hyprctl reload
#fi
